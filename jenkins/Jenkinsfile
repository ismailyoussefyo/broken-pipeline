pipeline {
    agent any

    environment {
        AWS_REGION = 'eu-central-1'
        AWS_DEFAULT_REGION = 'eu-central-1'
        APP_NAME = 'hello-world'
        ECS_CLUSTER = 'broken-pipeline-app'
        ECS_SERVICE = 'broken-pipeline-app-service'
        EMAIL_RECIPIENTS = 'ismailmostafa.y@gmail.com'
    }

    options {
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }

    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
            }
        }

        stage('Build Docker Image') {
            steps {
                echo 'Building Docker image from Dockerfile...'
                script {
                    // FLAW #2: Missing error handling - if docker build fails, pipeline continues
                    // The Build stage executes Docker commands without checking return codes
                    // If docker build fails, the pipeline continues to the next stage without failing
                    // Impact: Pipeline may report success even when builds fail, leading to deployment of broken images
                    // Fix: Add error checking: docker build ... || exit 1
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                    sh '''
                            echo "=========================================="
                            echo "Building custom Docker image"
                            echo "Dockerfile: ./Dockerfile"
                            echo "Build Number: ${BUILD_NUMBER}"
                            echo "=========================================="

                            # Generate timestamp-based image tag
                            IMAGE_TAG=$(date +%Y%m%d%H%M)
                            echo "Image Tag: $IMAGE_TAG"
                            echo $IMAGE_TAG > image_tag.txt

                            # Get AWS account ID and ECR repository URL
                            AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
                            ECR_REPO_NAME="broken-pipeline-app"
                            ECR_REPO_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO_NAME}"
                            echo $ECR_REPO_URI > ecr_repo.txt

                            # FLAW #2: Build without error checking
                            # If build fails, pipeline continues anyway
                            # Use --no-cache to ensure Dockerfile changes are picked up
                            docker build --no-cache -f Dockerfile -t ${APP_NAME}:$IMAGE_TAG .
                            docker tag ${APP_NAME}:$IMAGE_TAG ${ECR_REPO_URI}:$IMAGE_TAG
                            docker tag ${APP_NAME}:$IMAGE_TAG ${ECR_REPO_URI}:latest

                            echo ""
                            echo "Images built and tagged:"
                            docker images | grep ${APP_NAME} | head -3
                            echo "=========================================="
                    '''
                    }
                }
            }
        }

        stage('Health Check') {
            steps {
                echo 'Running health check...'
                script {
                    // FLAW #3: Health check script only verifies container is running
                    // Does not actually test HTTP endpoint - see verify_health.sh
                    sh '''
                        chmod +x scripts/verify_health.sh
                        IMAGE_TAG=$(cat image_tag.txt)
                        ./scripts/verify_health.sh ${APP_NAME}:$IMAGE_TAG || echo "‚ö†Ô∏è Health check warning (see logs)"
                    '''
                }
            }
        }

        stage('Push to ECR') {
            steps {
                echo 'Pushing image to ECR...'
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        sh '''
                            echo "=========================================="
                            echo "Pushing Docker image to ECR"
                            echo "=========================================="

                            IMAGE_TAG=$(cat image_tag.txt)
                            ECR_REPO_URI=$(cat ecr_repo.txt)

                            echo "Logging in to ECR..."
                            aws ecr get-login-password --region ${AWS_REGION} | \
                                docker login --username AWS --password-stdin ${ECR_REPO_URI}

                            echo ""
                            echo "Pushing images..."
                            docker push ${ECR_REPO_URI}:$IMAGE_TAG
                            docker push ${ECR_REPO_URI}:latest

                            echo ""
                            echo "‚úÖ Images pushed successfully!"
                            echo "  - ${ECR_REPO_URI}:$IMAGE_TAG"
                            echo "  - ${ECR_REPO_URI}:latest"
                            echo "=========================================="
                        '''
                    }
                }
            }
        }

        stage('Deploy to ECS') {
            steps {
                echo 'Deploying new image to ECS...'
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        sh '''
                            echo "=========================================="
                            echo "Deploying to ECS"
                            echo "=========================================="

                            IMAGE_TAG=$(cat image_tag.txt)
                            echo "Updating ECS service ${ECS_SERVICE} in cluster ${ECS_CLUSTER}..."
                            echo "Image Tag: $IMAGE_TAG"
                            echo ""

                            # Force new deployment - ECS will pull latest image from ECR
                            aws ecs update-service \
                                --cluster ${ECS_CLUSTER} \
                                --service ${ECS_SERVICE} \
                                --force-new-deployment \
                                --region ${AWS_REGION}

                            echo ""
                            echo "‚úÖ Deployment triggered successfully!"
                            echo "ECS will:"
                            echo "  1. Pull image with tag :latest from ECR"
                            echo "  2. Stop old tasks"
                            echo "  3. Start new tasks with new image"
                            echo "=========================================="
                        '''
                    }
                }
            }
        }

        stage('Verify Deployment') {
            steps {
                echo 'Verifying deployment...'
                script {
                    sh '''
                        echo "Waiting 30 seconds for deployment to stabilize..."
                        sleep 30
                        echo "‚úÖ Deployment verification complete"
                    '''
                }
            }
        }

        stage('Log to S3') {
            steps {
                echo 'Uploading pipeline logs to S3...'
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        sh '''
                            echo "=========================================="
                            echo "Uploading logs to S3"
                            echo "=========================================="

                            S3_LOG_BUCKET="broken-pipeline-app-logs-$(aws sts get-caller-identity --query Account --output text)"
                            BUILD_LOG_PATH="pipeline-logs/${JOB_NAME}/${BUILD_TAG}"

                            # FLAW #4 (Cost Issue): Uploading entire Jenkins log directory
                            # This recursively uploads ALL Jenkins logs, not just this build
                            # Impact: Uploads grow exponentially, inflating S3 storage costs
                            # Fix: Upload only current build log: aws s3 cp ${WORKSPACE}/build.log s3://...

                            echo "Uploading Jenkins logs recursively (WARNING: Cost inefficient)..."
                            aws s3 cp /var/jenkins_home/jobs/ s3://${S3_LOG_BUCKET}/${BUILD_LOG_PATH}/ \
                                --recursive \
                                --region ${AWS_REGION} \
                                --only-show-errors || echo "‚ö†Ô∏è Some log files could not be uploaded"

                            echo ""
                            echo "‚úÖ Logs uploaded to S3"
                            echo "Location: s3://${S3_LOG_BUCKET}/${BUILD_LOG_PATH}/"
                            echo "=========================================="
                        '''
                    }
                }
            }
        }

        stage('Notify SNS') {
            steps {
                echo 'Sending SNS notification...'
                script {
                    withCredentials([
                        string(credentialsId: 'aws-access-key-id', variable: 'AWS_ACCESS_KEY_ID'),
                        string(credentialsId: 'aws-secret-access-key', variable: 'AWS_SECRET_ACCESS_KEY')
                    ]) {
                        // Get build result as Groovy variable
                        def buildResult = currentBuild.currentResult ?: 'SUCCESS'

                        sh """
                            echo "=========================================="
                            echo "Sending SNS notification"
                            echo "=========================================="

                            SNS_TOPIC_ARN=\$(aws sns list-topics --region ${AWS_REGION} \\
                                --query "Topics[?contains(TopicArn, 'broken-pipeline-alarms')].TopicArn" \\
                                --output text)

                            IMAGE_TAG=\$(cat image_tag.txt)
                            RESULT="${buildResult}"

                            MESSAGE="Pipeline ${JOB_NAME} build #${BUILD_NUMBER} completed with status: \${RESULT}

Image Tag: \${IMAGE_TAG}
Build URL: ${BUILD_URL}
Deployed to: ${ECS_CLUSTER}/${ECS_SERVICE}"

                            aws sns publish \\
                                --topic-arn \${SNS_TOPIC_ARN} \\
                                --message "\${MESSAGE}" \\
                                --subject "Deployment Result: \${RESULT} - ${JOB_NAME}" \\
                                --region ${AWS_REGION}

                            echo ""
                            echo "‚úÖ SNS notification sent successfully!"
                            echo "=========================================="
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            echo '========================================'
            echo 'Pipeline execution completed'
            echo '========================================'
            script {
                // Cleanup Docker images
                sh 'docker system prune -f || true'
                // Clean workspace
                cleanWs()
            }
        }
        success {
            echo 'Pipeline succeeded!'
            emailext (
                subject: "‚úÖ Pipeline SUCCESS: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                body: """
                    <h2>Pipeline Execution Successful! üéâ</h2>

                    <h3>Build Information:</h3>
                    <ul>
                        <li><strong>Job Name:</strong> ${env.JOB_NAME}</li>
                        <li><strong>Build Number:</strong> ${env.BUILD_NUMBER}</li>
                        <li><strong>Build URL:</strong> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></li>
                        <li><strong>Console Output:</strong> <a href="${env.BUILD_URL}console">${env.BUILD_URL}console</a></li>
                    </ul>

                    <h3>Pipeline Stages Completed:</h3>
                    <ol>
                        <li>‚úÖ Checkout - Source code pulled from Git</li>
                        <li>‚úÖ Build Docker Image - Built with timestamp-based tag</li>
                        <li>‚úÖ Health Check - Container verification (Flaw #3: No HTTP test)</li>
                        <li>‚úÖ Push to ECR - Image pushed with :latest tag</li>
                        <li>‚úÖ Deploy to ECS - Force new deployment triggered</li>
                        <li>‚úÖ Verify Deployment - 30s stabilization check</li>
                        <li>‚úÖ Log to S3 - Pipeline logs stored (Flaw #4: Cost inefficient)</li>
                        <li>‚úÖ SNS Notification - Alert sent to subscribers</li>
                    </ol>

                    <h3>Deployment Details:</h3>
                    <p>‚úÖ Successfully deployed to ECS cluster: <strong>${env.ECS_CLUSTER}</strong></p>
                    <p>‚úÖ Service updated: <strong>${env.ECS_SERVICE}</strong></p>
                    <p>üì¶ Image tagged with timestamp and pushed to ECR as :latest</p>

                    <hr>
                    <p><em>This is an automated email from Jenkins CI/CD Pipeline</em></p>
                """,
                to: "${env.EMAIL_RECIPIENTS}",
                mimeType: 'text/html'
            )
        }
        failure {
            echo 'Pipeline failed!'
            emailext (
                subject: "‚ùå Pipeline FAILURE: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                body: """
                    <h2>Pipeline Execution Failed! ‚ö†Ô∏è</h2>

                    <h3>Build Information:</h3>
                    <ul>
                        <li><strong>Job Name:</strong> ${env.JOB_NAME}</li>
                        <li><strong>Build Number:</strong> ${env.BUILD_NUMBER}</li>
                        <li><strong>Build URL:</strong> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></li>
                        <li><strong>Console Output:</strong> <a href="${env.BUILD_URL}console">${env.BUILD_URL}console</a></li>
                    </ul>

                    <h3>Action Required:</h3>
                    <ol>
                        <li>Check the <a href="${env.BUILD_URL}console">console output</a> for error details</li>
                        <li>Review AWS credentials and permissions</li>
                        <li>Verify Docker image build succeeded</li>
                        <li>Check ECR repository access</li>
                        <li>Verify ECS cluster and service status</li>
                    </ol>

                    <h3>Common Issues:</h3>
                    <ul>
                        <li>üêõ Docker build failures (Flaw #2: Missing error handling)</li>
                        <li>üîç Health check failures (Flaw #3: Only checks container running, not HTTP)</li>
                        <li>üîê AWS credential/permission issues</li>
                        <li>üì¶ ECR push failures</li>
                        <li>üöÄ ECS deployment errors</li>
                        <li>üìù S3 log upload issues</li>
                        <li>üìß SNS notification failures</li>
                    </ul>

                    <hr>
                    <p><em>This is an automated email from Jenkins CI/CD Pipeline</em></p>
                """,
                to: "${env.EMAIL_RECIPIENTS}",
                mimeType: 'text/html'
            )
        }
        unstable {
            echo 'Pipeline unstable!'
            emailext (
                subject: "‚ö†Ô∏è  Pipeline UNSTABLE: ${env.JOB_NAME} - Build #${env.BUILD_NUMBER}",
                body: """
                    <h2>Pipeline Execution Unstable ‚ö†Ô∏è</h2>

                    <h3>Build Information:</h3>
                    <ul>
                        <li><strong>Job Name:</strong> ${env.JOB_NAME}</li>
                        <li><strong>Build Number:</strong> ${env.BUILD_NUMBER}</li>
                        <li><strong>Build URL:</strong> <a href="${env.BUILD_URL}">${env.BUILD_URL}</a></li>
                        <li><strong>Console Output:</strong> <a href="${env.BUILD_URL}console">${env.BUILD_URL}console</a></li>
                    </ul>

                    <p>The pipeline completed but some tests or checks were unstable.</p>
                    <p>Please review the console output to identify issues.</p>

                    <hr>
                    <p><em>This is an automated email from Jenkins CI/CD Pipeline</em></p>
                """,
                to: "${env.EMAIL_RECIPIENTS}",
                mimeType: 'text/html'
            )
        }
    }
}
